#!/usr/bin/python3

# TODO: also generate Message enums

from re import sub

CONTROLLABLES = [
    ("adsr_envelope", ["note"]),
    ("arpeggiator", ["nothing"]),
    ("bi_quad_filter", ["bandwidth", "cutoff_pct", "db_gain", "q"]),
    ("bitcrusher", ["bits_to_crush_pct"]),
    ("gain", ["ceiling"]),
    ("limiter", ["max", "min"]),
    ("mixer", []),
    ("oscillator", ["frequency"]),
]


def camel_case(s):
    s = sub(r"(_|-)+", " ", s).title().replace(" ", "")
    if len(s) > 1:
        return ''.join([s[0], s[1:]])
    else:
        return s[0]


def emit_enums(target, params):
    enums = []
    for param in params:
        enums.append(
            "{p},".format(
                t=camel_case(target), p=camel_case(param)))
    print("""
#[derive(Display, Debug, EnumString)]
#[strum(serialize_all = "kebab_case")]
pub(crate) enum {t}ControlParams {{ {enums} }}
""".format(t=camel_case(target), enums="".join(enums)))


MESSAGE_NAMES = ["ValueChanged",
                 "SecondValueChanged",
                 "ThirdValueChanged",
                 "FourthValueChanged",
                 ]


message_name_index = 0


def get_next_message_name():
    global message_name_index
    s = MESSAGE_NAMES[message_name_index]
    message_name_index += 1
    return s


def emit_is_updateable(target, params):
    global message_name_index
    match_arms = []
    message_name_index = 0
    for param in params:
        match_arms.append(
            "{t}ControlParams::{p} => return Box::new(SmallMessage::{m}),".format(
                t=camel_case(target), p=camel_case(param), m=get_next_message_name()))
    if len(match_arms) > 0:
        match_block = "match param {{ {match_arms} }}".format(
            match_arms="\n".join(match_arms))
    else:
        match_block = ""

    match_arms = []
    message_name_index = 0
    for param in params:
        match_arms.append(
            "SmallMessage::{m}(value) => self.set_{p}(value),".format(
                t=camel_case(target), p=param, m=get_next_message_name()))
    if len(match_arms) > 0:
        update_match_block = "match message {{ {match_arms} _=>{{}}}}".format(
            match_arms="\n".join(match_arms))
    else:
        update_match_block = ""

    print("""
impl IsUpdateable for {t} {{
  fn message_for(&self, param_name: &str) -> SmallMessageGenerator {{
    if let Ok(param) = {t}ControlParams::from_str(param_name) {{
      {match_block}
    }}
    panic!("unrecognized parameter name: {{}}", param_name);
  }}

  fn update(&mut self, clock: &Clock, message: SmallMessage) {{
      {update_match_block}
  }}
}}
""".format(t=camel_case(target), match_block=match_block, update_match_block=update_match_block))


def emit_makes_control_sink(target, params):
    match_arms = []
    for param in params:
        match_arms.append(
            "{t}ControlParams::{p} => return Some(Box::new({t}{p}Controller {{target:wrc_clone(&self.me)}})),".format(
                t=camel_case(target), p=camel_case(param)))
    if len(match_arms) > 0:
        match_block = "match param {{ {match_arms} }}".format(
            match_arms="\n".join(match_arms))
    else:
        match_block = ""
    print("""
impl MakesControlSink for {t} {{
  fn make_control_sink(&self, param_name: &str) -> Option<Box<dyn SinksControl>> {{
    if self.me.strong_count() != 0 {{
      if let Ok(param) = {t}ControlParams::from_str(param_name) {{
        {{ {match_block} }}
  }}}} None}}}}
""".format(t=camel_case(target), match_block=match_block))


def emit_controller(target, param):
    target_cc = camel_case(target)
    param_cc = camel_case(param)
    print("""
#[derive(Debug)]
pub struct {t_cc}{p_cc}Controller {{ target: Ww<{t_cc}>, }}
impl SinksControl for {t_cc}{p_cc}Controller {{
  fn handle_control(&mut self, _clock: &Clock, value: f32) {{
    if let Some(target) = self.target.upgrade() {{ target.borrow_mut().set_{p}(value); }}}}}}
""".format(t_cc=target_cc, p_cc=param_cc, p=param))


print("// ############################################################################")
print("// BEGIN code generated by util/generate-controllers.py")

for controllable in CONTROLLABLES:
    target = controllable[0]
    params = controllable[1]
    emit_enums(target, params)
    #emit_makes_control_sink(target, params)
    emit_is_updateable(target, params)
#    for param in params:
#        emit_controller(target, param)

print("// END code generated by util/generate-controllers.py")
print("// ############################################################################")
